{smcl}
{com}{sf}{ul off}{txt}
{com}. use "https://raw.githubusercontent.com/wjnkim/tmo/master/example/county_panel.dta", clear
{txt}
{com}. 
. qui ds fips stfips EMN_farm EDU_publicenroll year, not
{txt}
{com}. local ylist `r(varlist)'
{txt}
{com}. 
. tmo_NP, cmd(reg EMN_farm EDU_publicenroll i.year i.stfips , ///
> cluster(fips)) x(EDU_publicenroll) ylist(`ylist') i(fips) t(year)
{res}{txt}{res}{err}                 <istmt>:  3257  nonpointer found where pointer required
{txt}{search r(3257), local:r(3257);}

end of do-file

{search r(3257), local:r(3257);}

{com}. do /var/folders/l2/y38hz3_d2ndd62p9krlby05r0000gn/T/StataRun1755475120669.do
{txt}
{com}. *sjlog using "$SJ/panelexample.tex", replace
. use "https://raw.githubusercontent.com/wjnkim/tmo/master/example/county_panel.dta", clear
{txt}
{com}. qui do "/Users/MacBook/Dropbox/Research/tmo/tmo_NP.ado"
{txt}
{com}. 
. qui ds fips stfips EMN_farm EDU_publicenroll year, not
{txt}
{com}. local ylist `r(varlist)'
{txt}
{com}. 
. tmo_NP, cmd(reg EMN_farm EDU_publicenroll i.year i.stfips , ///
> cluster(fips)) x(EDU_publicenroll) ylist(`ylist') i(fips) t(year)
{res}{txt}{res}{err}                 <istmt>:  3257  nonpointer found where pointer required
{txt}{search r(3257), local:r(3257);}

end of do-file

{search r(3257), local:r(3257);}

{com}. do /var/folders/l2/y38hz3_d2ndd62p9krlby05r0000gn/T/StataRun1755475181279.do
{txt}
{com}. *sjlog using "$SJ/panelexample.tex", replace
. use "https://raw.githubusercontent.com/wjnkim/tmo/master/example/county_panel.dta", clear
{txt}
{com}. qui do "/Users/MacBook/Dropbox/Research/tmo/tmo_NP.ado"
{txt}
{com}. 
. qui ds fips stfips EMN_farm EDU_publicenroll year, not
{txt}
{com}. local ylist `r(varlist)'
{txt}
{com}. 
. tmo_NP, cmd(reg EMN_farm EDU_publicenroll i.year i.stfips , ///
> cluster(fips)) x(EDU_publicenroll) ylist(`ylist') i(fips) t(year)
{res}{txt}{res}{err}                 <istmt>:  3257  nonpointer found where pointer required
{txt}{search r(3257), local:r(3257);}

end of do-file

{search r(3257), local:r(3257);}

{com}. do /var/folders/l2/y38hz3_d2ndd62p9krlby05r0000gn/T/StataRun1755475201853.do
{txt}
{com}. // Example file
. 
. global SJ "/Users/MacBook/Dropbox/Research/tmo/SJ/paper/examples"
{txt}
{com}. 
. clear all
{res}{txt}
{com}. do "/Users/MacBook/Dropbox/Research/tmo/tmo_NP.ado"
{txt}
{com}. *! version 0.9.0b3 2025-04-22
. 
. capture program drop tmo_NP
{txt}
{com}. program define tmo_NP, eclass
{txt}  1{com}.     version 13
{txt}  2{com}. 
.     syntax, ///
>         cmd(str) x(varname) ylist(varlist) Idvar(varname) ///
>         [Timevar(varname)] ///
>         [LATitude(varname)] [LONgitude(varname)] [DISTTHREShold(real 0)] [miles] ///
>         [THREShold(real -9)] [thresholdoff] ///
>         [MISSlimit(real 0.1)] ///
>         [FILEsuffix(str)] ///
>         [savedyad] [load(str)] ///
>         [plotq] ///
>         [plothist] [plothistnbins(int 10000)] ///
>         [plotse] [saveplotseest] ///
>         [saveest] ///
>         [scpc_cmd(str)] [scpc_uncond]
{txt}  3{com}.    
.     ********************************
.     *** RUN AND SAVE CMD OPTIONS ***
.     ********************************
. 
.     // DC: Could allow alternative estimation procedures provided they 
.     //   are e-class if some judicious unpacking of arguments is done? 
.     qui `cmd'
{txt}  4{com}.     local spec `e(cmd)' 
{txt}  5{com}.     // DC: Adding for ereturn display
.     marksample touse
{txt}  6{com}.     local r2a = e(r2_a)
{txt}  7{com}.     local r2  = e(r2_a)
{txt}  8{com}.     local nobs = e(N)
{txt}  9{com}.     local rmse = e(rmse)
{txt} 10{com}.     local depvar = e(depvar)
{txt} 11{com}. 
.     * Assert that cmd uses supported command
.     if !inlist("`spec'","regress","reghdfe","areg","ivreghdfe","ivreg2","ivregress") {c -(}
{txt} 12{com}.             di as error "`spec' not supported"
{txt} 13{com}.             exit
{txt} 14{com}.     {c )-}
{txt} 15{com}. 
.     * Store original results and options
.     local y `e(depvar)'
{txt} 16{com}.     scalar beta    = _b[`x']
{txt} 17{com}.     scalar se      = _se[`x']
{txt} 18{com}.     scalar N_obs   = e(N)
{txt} 19{com}.     scalar N_clust = e(N_clust)
{txt} 20{com}.     scalar df_r    = e(df_r)
{txt} 21{com}.     
.     tempvar tmo_sample
{txt} 22{com}.     gen byte `tmo_sample' = e(sample)
{txt} 23{com}. 
.     * Extract clusters
.     local cluster `e(clustvar)'
{txt} 24{com}.     
.     * Extract absorb vars for (iv)reghdfe adn areg
.     local absorb_vars `e(absvars)' `e(absvar)'
{txt} 25{com}. 
.     * Extract weights
.     if "`e(wexp)'"!="" {c -(}
{txt} 26{com}.         local weightvar = subinstr("`e(wexp)'","=","",1)
{txt} 27{com}.         local weightexp [`e(wtype)'`e(wexp)']
{txt} 28{com}.     {c )-}
{txt} 29{com}.     else {c -(}
{txt} 30{com}.         local weightvar
{txt} 31{com}.         local weightexp
{txt} 32{com}.     {c )-}
{txt} 33{com}. 
.     *** END RUN AND SAVE CMD OPTIONS ***
. 
. 
.     *************************
.     *** RUN SCPC IF GIVEN ***
.     *************************
.     
.     if "`scpc_cmd'"!="" {c -(}
{txt} 34{com}.         // Install edited version of scpc that stores critical values
.         // DC: Let's bundle this with tmo.  
.            // This avoids issues if users have something else located in their 
.         qui net install scpc, from("https://raw.githubusercontent.com/wjnkim/tmo/master/scpc_tmo") replace
{txt} 35{com}. 
.         preserve
{txt} 36{com}.             qui keep if !missing(`longitude') & !missing(`latitude') & `tmo_sample'
{txt} 37{com}. 
.             rename `latitude' s_1
{txt} 38{com}.             rename `longitude' s_2
{txt} 39{com}.             
.             qui hashsort `idvar'
{txt} 40{com}.             qui `scpc_cmd'
{txt} 41{com}.             qui keep if e(sample)
{txt} 42{com}.             if "`scpc_uncond'"=="" {c -(}
{txt} 43{com}.                 qui scpc, k(1) latlong
{txt} 44{com}.             {c )-}
{txt} 45{com}.             else {c -(}
{txt} 46{com}.                 qui scpc, k(1) latlong uncond
{txt} 47{com}.             {c )-}
{txt} 48{com}.             scalar scpc_se=e(scpcstats)[1,2]
{txt} 49{com}.         
.             mata: id_scpc = st_data(.,"`idvar'")
{txt} 50{com}.             clear
{txt} 51{com}. 
.             mata: id_scpc_uniq = uniqrows(id_scpc)
{txt} 52{com}.             mata: Wfin_sum_vec = vec(Wfin[.,2::cols(Wfin)]*Wfin[.,2::cols(Wfin)]'):/(cols(Wfin)-1)
{txt} 53{com}.             mata: id_scpc_rowvec = vec(J(1,rows(Wfin),id_scpc_uniq))
{txt} 54{com}.             mata: id_scpc_colvec = vec(J(rows(Wfin),1,id_scpc_uniq'))
{txt} 55{com}.                 
.             mata: st_local("scpc_obsN",strofreal(rows(Wfin_sum_vec),"%50.0f"))
{txt} 56{com}. 
.             gen id1=.
{txt} 57{com}.             gen id2=.
{txt} 58{com}.             gen Wfin=.
{txt} 59{com}.                 
.             qui set obs `scpc_obsN'
{txt} 60{com}.             
.             mata: st_store(.,.,(id_scpc_rowvec,id_scpc_colvec,Wfin_sum_vec))
{txt} 61{com}.             
.             qui keep if id1>=id2 // keep only lower triangular
{txt} 62{com}. 
.             qui compress
{txt} 63{com}.             tempfile Wfin
{txt} 64{com}.             qui save `Wfin'
{txt} 65{com}.         restore
{txt} 66{com}.     {c )-}
{txt} 67{com}.     else {c -(}
{txt} 68{com}.         global scpc_cv = .
{txt} 69{com}.     {c )-}
{txt} 70{com}. 
.     *** END RUN SCPC IF GIVEN ***
. 
. 
. 
.     *********************
.     *** OPTION CHECKS ***
.     *********************
. 
.     * Assert gtools installed
.     cap which gtools
{txt} 71{com}.     if _rc {c -(}
{txt} 72{com}.         di as error "tmo requires gtools package -- please run: ssc install gtools"
{txt} 73{com}.         exit
{txt} 74{com}.     {c )-}
{txt} 75{com}. 
.     * Assert that y and x are in cmd and y is the dependent variable
.     local ycheck: word 2 of `cmd'
{txt} 76{com}.         if strpos("`cmd'","`y'")==0 | strpos("`cmd'","`x'")==0 | "`y'"!="`ycheck'" {c -(}
{txt} 77{com}.                 di as error "cmd must contain `y' and `x' and `y' must be independent var"
{txt} 78{com}.                 exit
{txt} 79{com}.         {c )-}
{txt} 80{com}. 
.     * Assert that y appears only once in cmd
.         if (strlen("`cmd'")-strlen(subinstr("`cmd'"," `y' ","",.)) != strlen(" `y' ")) {c -(}
{txt} 81{com}.                 di as error "cmd contains multiple instances of `y'"
{txt} 82{com}.                 exit
{txt} 83{com}.         {c )-}
{txt} 84{com}. 
.     * Assert that x appears only once in cmd
.         if (strlen("`cmd'")-strlen(subinstr("`cmd'","`x'","",.)) != strlen("`x'")) {c -(}
{txt} 85{com}.                 di as error "cmd contains multiple instances of `x', please rename variables"
{txt} 86{com}.                 exit
{txt} 87{com}.         {c )-}
{txt} 88{com}. 
.     * Assert no duplicates in y ylist
.     local done ""
{txt} 89{com}.     local dups ""
{txt} 90{com}.     foreach var in `y' `ylist' {c -(}
{txt} 91{com}.         confirm var `var', exact
{txt} 92{com}.         if strpos("`done'"," `var' ")>0 {c -(}
{txt} 93{com}.             local dups "`dups' `var'"
{txt} 94{com}.         {c )-}
{txt} 95{com}.         local done "`done' `var'"
{txt} 96{com}.     {c )-}
{txt} 97{com}.     if "`dups'"!="" {c -(}
{txt} 98{com}.         di as error "Duplicated variables in depvar/ylist: `dups'"
{txt} 99{com}.         exit
{txt}100{com}.     {c )-}
{txt}101{com}. 
.     * Assert misslimit is between 0 and 1
.     if `misslimit'<0 | `misslimit'>1 {c -(}
{txt}102{com}.         di as error "misslimit() value must be between 0 and 1"
{txt}103{com}.         exit
{txt}104{com}.     {c )-}
{txt}105{com}. 
.     * Assert plothistnbins is positive if given
.     if `plothistnbins'<=0 {c -(}
{txt}106{com}.         di as error "plothistnbins() value must be positive"
{txt}107{com}.         exit
{txt}108{com}.     {c )-}
{txt}109{com}. 
.     * saveplotse requires plotse option
.     if "`plotse'"=="" & "`saveplotse'"!="" {c -(}
{txt}110{com}.         di as error "saveplotse option requires plotse option"
{txt}111{com}.         exit
{txt}112{com}.     {c )-}
{txt}113{com}. 
.     * Require file path for saving figures/data
.     if "`filesuffix'"=="" & ("`plotse'"!="" | "`plothist'"!="" | "`savedyad'"!="" | "`saveplotseest'"!="" | "`saveest'"!="") {c -(}
{txt}114{com}.         di as error "filesuffix() required for `plotse' `plothist' `savedyad' `saveplotseest' `saveest'"
{txt}115{com}.     {c )-}
{txt}116{com}. 
.     * Require clustering (at least at location level) if panel
.     if "`timevar'"!="" & "`cluster'"=="" {c -(}
{txt}117{com}.         di as error "Clustering required for panel case (at least at `id' level)"
{txt}118{com}.         exit
{txt}119{com}.     {c )-}
{txt}120{com}. 
.     * Require absorb if (iv)reghdfe
.     if inlist("`spec'","reghdfe","ivreghdfe", "areg") & "`absorb_vars'"=="" {c -(}
{txt}121{com}.         di as error "absorb() required for `spec'"
{txt}122{com}.         exit
{txt}123{com}.     {c )-}
{txt}124{com}. /*
>     * Require xtset if xtreg
>     capture xtset
>     if "`spec'" == "xtreg"{c -(}
>         capture xtset
>         if _rc {c -(}
>             di as error "ERROR: Panel no declarado. Usa `xtset´ antes de `xtreg_safe´."
>             exit 198
>         {c )-}
>     {c )-}
> */
.     * Assert idvar is unique (within timevar if panel)
.         if "`idvar'"!="" & "`timevar'"=="" {c -(}
{txt}125{com}.                 gisid `idvar' if `tmo_sample'
{txt}126{com}.         {c )-}
{txt}127{com}.         if "`idvar'"!="" & "`timevar'"!="" {c -(}
{txt}128{com}.                 gisid `idvar' `timevar' if `tmo_sample'
{txt}129{com}.         {c )-}
{txt}130{com}. 
.     * Assert longitude and latitude provided if distthreshold!=0
.     if ("`longitude'"=="" | "`latitude'"=="") & `distthreshold'!=0 {c -(}
{txt}131{com}.         di as error "longitude() and latitude() required for distthreshold() option"
{txt}132{com}.         exit
{txt}133{com}.     {c )-}
{txt}134{com}. 
.     * Assert longitude and latitude provided if scpc
.     if ("`longitude'"=="" | "`latitude'"=="") & "`scpc_cmd'"!="" {c -(}
{txt}135{com}.         di as error "longitude() and latitude() required for scpc_cmd() option"
{txt}136{com}.         exit
{txt}137{com}.     {c )-}
{txt}138{com}. 
.     * Assert scpc_cmd() if scpc_uncond option
.     if "`scpc_cmd'"=="" & "`scpc_uncond'"!="" {c -(}
{txt}139{com}.         di as error "scpc_cmd() required for scpc_uncond() option"
{txt}140{com}.         exit
{txt}141{com}.     {c )-}
{txt}142{com}. 
.     * Assert no weights if scpc
.     if "`scpc_cmd'"!="" & "`weightvar'"!="" {c -(}
{txt}143{com}.         di as error "weights not allowed for scpc"
{txt}144{com}.         exit
{txt}145{com}.     {c )-}
{txt}146{com}. 
.     * Assert distthreshold>0 if provided
.     if `distthreshold'<0 {c -(}
{txt}147{com}.         di as error "distthreshold() must be greater than 0"
{txt}148{com}.         exit
{txt}149{com}.     {c )-}
{txt}150{com}. 
.     * Assert geodist package installed if distthreshold>0
.     if `distthreshold'>0 {c -(}
{txt}151{com}.         cap which geodist
{txt}152{com}.         if _rc {c -(}
{txt}153{com}.             di as error "distthreshold() requires geodist package -- please run: ssc install geodist"
{txt}154{com}.             exit
{txt}155{com}.         {c )-}
{txt}156{com}.     {c )-}
{txt}157{com}. 
.     * Assert custom threshold is between 0 and 1 if provided
.     if `threshold'!=-9 & (`threshold'<0 | `threshold'>1) {c -(}
{txt}158{com}.         di as error "Custom threshold() must be between 0 and 1"
{txt}159{com}.         exit
{txt}160{com}.     {c )-}
{txt}161{com}. 
.     * Store number of locations and time periods
.     qui gdistinct `idvar' if `tmo_sample'
{txt}162{com}.     local N = r(ndistinct)
{txt}163{com}.     scalar N = `r(ndistinct)'
{txt}164{com}.     mata: N = `N'
{txt}165{com}.     if "`timevar'"!="" {c -(}
{txt}166{com}.         qui gdistinct `timevar' if `tmo_sample'
{txt}167{com}.         local T = r(ndistinct)
{txt}168{com}.         scalar T = r(ndistinct)
{txt}169{com}.         mata: T = `T'
{txt}170{com}.     {c )-}
{txt}171{com}.     else {c -(}
{txt}172{com}.         local T = 1
{txt}173{com}.         scalar T = 1
{txt}174{com}.         mata: T = 1
{txt}175{com}.     {c )-}
{txt}176{com}. 
.     *** END OPTION CHECKS ***
. 
. 
. 
.     *****************
.     *** CLEAN CMD ***
.     *****************
.     
.     if inlist("`spec'","reghdfe","ivreghdfe","areg") {c -(}
{txt}177{com}.         * Remove any resid specified in cmd already
.         local comma_start  = strpos("`cmd'", ",")
{txt}178{com}.         local before_comma = substr("`cmd'", 1, `comma_start'-1)
{txt}179{com}.         local after_comma  = substr("`cmd'", `comma_start'+1, .)
{txt}180{com}.         local after_comma  = regexr("`after_comma'", "(res|resi|resid|residu|residua|residual|residuals)\([^)]*\)", "")
{txt}181{com}.         local after_comma  = regexr("`after_comma'", "(res|resi|resid|residu|residua|residual|residuals)", "")
{txt}182{com}. 
.         * Remove saving FE options
.         local after_comma = regexr("`after_comma'", "(a|ab|abs|abso|absor|absorb)\([^)]*\)", "")
{txt}183{com}. 
.         local cmd `before_comma', absorb(`absorb_vars') `after_comma'
{txt}184{com}.     {c )-}
{txt}185{com}. 
.     *** END CLEAN CMD ***
. 
. 
. 
.     ****************************
.     *** STORE ID-CLUSTER XW ****
.     ****************************
. 
.     if "`cluster'"!="" & "`cluster'"!="`idvar'" {c -(}
{txt}186{com}.         preserve
{txt}187{com}.             qui keep if `tmo_sample'
{txt}188{com}.             keep `idvar' `cluster'
{txt}189{com}. 
.             qui gduplicates drop
{txt}190{com}.             cap gisid `idvar'
{txt}191{com}. 
.             if _rc {c -(}
{txt}192{com}.                 di as error "Only clustering by groups of locations is supported (`cluster' must be constant within `idvar')"
{txt}193{com}.                 exit
{txt}194{com}.             {c )-}
{txt}195{com}. 
.             local cln=1
{txt}196{com}.             foreach var in `cluster' {c -(}
{txt}197{com}.                 rename `var' __tmo_cl1_`cln'
{txt}198{com}.                 local ++cln
{txt}199{com}.             {c )-}
{txt}200{com}.             rename `idvar' id1
{txt}201{com}.             qui compress
{txt}202{com}.             tempfile cl1
{txt}203{com}.             qui save `cl1'
{txt}204{com}. 
.             local cln=1
{txt}205{com}.             foreach var in `cluster' {c -(}
{txt}206{com}.                 rename __tmo_cl1_`cln' __tmo_cl2_`cln'
{txt}207{com}.                 local ++cln
{txt}208{com}.             {c )-}
{txt}209{com}.             rename id1 id2
{txt}210{com}.             tempfile cl2
{txt}211{com}.             qui save `cl2'
{txt}212{com}.         restore
{txt}213{com}.     {c )-}
{txt}214{com}. 
.     *** END STORE ID-CLUSTER XW ***
. 
. 
. 
.     *********************************
.     *** STORE LOCATION DISTANCES ****
.     *********************************
. 
.     if "`longitude'"!="" & "`latitude'"!="" {c -(}
{txt}215{com}.         preserve
{txt}216{com}.             qui keep if `tmo_sample'
{txt}217{com}.             keep `idvar' `longitude' `latitude'
{txt}218{com}. 
.             qui gduplicates drop
{txt}219{com}.             cap gisid `idvar'
{txt}220{com}. 
.             if _rc {c -(}
{txt}221{com}.                 di as error "`longitude' and/or `latitude' not constant within some `idvar'"
{txt}222{com}.                 exit
{txt}223{com}.             {c )-}
{txt}224{com}. 
.             gen n=_n
{txt}225{com}.                 
.             rename `latitude'  lat2
{txt}226{com}.             rename `longitude' lon2
{txt}227{com}.             rename `idvar' id2
{txt}228{com}.             qui compress
{txt}229{com}. 
.             tempfile dist
{txt}230{com}.             qui save `dist'
{txt}231{com}.             
.             rename id2 id1
{txt}232{com}.             rename lat2 lat1
{txt}233{com}.             rename lon2 lon1    
{txt}234{com}.             
.             qui sum n
{txt}235{com}.             qui expand `r(max)'
{txt}236{com}.             drop n
{txt}237{com}.             
.             qui hashsort id1
{txt}238{com}.             by id1: gen n=_n
{txt}239{com}.             
.             qui merge m:1 n using `dist', assert(3) nogen
{txt}240{com}.             drop n
{txt}241{com}. 
.             qui keep if id1>=id2 // keep only lower triangular
{txt}242{com}.             
.             qui geodist lat1 lon1 lat2 lon2, gen(dist) `miles' sphere
{txt}243{com}.             qui replace dist=0 if id1==id2
{txt}244{com}. 
.             keep id1 id2 dist
{txt}245{com}. 
.             qui compress   
{txt}246{com}.             tempfile dist
{txt}247{com}.             qui save `dist'
{txt}248{com}.         restore
{txt}249{com}.     {c )-}
{txt}250{com}. 
.     *** END STORE LOCATION DISTANCES ***
. 
. 
. 
.     ****************************
.     *** WRITE CMD FOR XTILDE ***
.     ****************************
. 
.     if  inlist("`spec'","regress","reghdfe", "areg") {c -(}
{txt}251{com}.         local xtildecmd = subinstr("`cmd'"," `y' "," `x' ",1)
{txt}252{com}.         local xtildecmd = subinstr("`xtildecmd'"," `x' "," ",2)
{txt}253{com}.         if "`spec'"=="reghdfe" {c -(}
{txt}254{com}.             local xtildecmd `xtildecmd' resid
{txt}255{com}.         {c )-}
{txt}256{com}.     {c )-}
{txt}257{com}.     if "`spec'"=="ivreghdfe" {c -(}        
{txt}258{com}.         * Create xtildecmd using ivreghdfe
.         local parens_start = strpos("`cmd'", "(")
{txt}259{com}.         local parens_end = strpos("`cmd'", ")")
{txt}260{com}.         local paren_content = substr("`cmd'", `parens_start' + 1, `parens_end' - `parens_start' - 1)
{txt}261{com}.         local instr_start = strpos("`paren_content'", "=")
{txt}262{com}.         local endog_part = substr("`paren_content'", 1, `instr_start'-1)
{txt}263{com}.         local endog = word("`endog_part'", 1)
{txt}264{com}.         if wordcount("`endog_part'") > 1 {c -(}
{txt}265{com}.             di as error "Multiple endogenous regressors not supported"
{txt}266{com}.             exit
{txt}267{com}.         {c )-}
{txt}268{com}.         if "`endog'"!="`x'" {c -(}
{txt}269{com}.             di as error "Endogenous regressor `endog' is not `x'"
{txt}270{com}.             exit
{txt}271{com}.         {c )-}
{txt}272{com}.         local instr = substr("`paren_content'", `instr_start' + 1, .)
{txt}273{com}. 
.         local remaining = subinstr("`cmd'", "ivreghdfe", "", 1)
{txt}274{com}.         local remaining = subinstr("`remaining'", "`y'", "", 1)
{txt}275{com}.         local comma_start = strpos("`remaining'", ",")
{txt}276{com}.         local after_comma = substr("`remaining'", `comma_start'+1, .)
{txt}277{com}.         local remaining = substr("`remaining'", 1, `comma_start'-1)
{txt}278{com}.         local paren_start = strpos("`remaining'", "(")
{txt}279{com}.         local paren_end = strpos("`remaining'", ")")
{txt}280{com}.         local controls = substr("`remaining'", 1, `paren_start'-1) + " " + substr("`remaining'", `paren_end'+1, .)
{txt}281{com}.         local xtildecmd1 reghdfe `endog' `instr' `controls', `after_comma'
{txt}282{com}.         local xtildecmd2 reghdfe __tmo_xhat `controls', `after_comma' resid
{txt}283{com}.     {c )-}
{txt}284{com}.     if "`spec'"=="ivreg2" {c -(}
{txt}285{com}.         * Create xtildecmd using reg
.         local parens_start = strpos("`cmd'", "(")
{txt}286{com}.         local parens_end = strpos("`cmd'", ")")
{txt}287{com}.         local paren_content = substr("`cmd'", `parens_start' + 1, `parens_end' - `parens_start' - 1)
{txt}288{com}.         local instr_start = strpos("`paren_content'", "=")
{txt}289{com}.         local endog_part = substr("`paren_content'", 1, `instr_start'-1)
{txt}290{com}.         local endog = word("`endog_part'", 1)
{txt}291{com}.         if wordcount("`endog_part'") > 1 {c -(}
{txt}292{com}.             di as error "Multiple endogenous regressors not supported"
{txt}293{com}.             exit
{txt}294{com}.         {c )-}
{txt}295{com}.         if "`endog'"!="`x'" {c -(}
{txt}296{com}.             di as error "Endogenous regressor `endog' is not `x'"
{txt}297{com}.             exit
{txt}298{com}.         {c )-}
{txt}299{com}.         local instr = substr("`paren_content'", `instr_start' + 1, .)
{txt}300{com}. 
.         local remaining = subinstr("`cmd'", "ivreg2", "", 1)
{txt}301{com}.         local remaining = subinstr("`remaining'", "`y'", "", 1)
{txt}302{com}.         local comma_start = strpos("`remaining'", ",")
{txt}303{com}.         local remaining = substr("`remaining'", 1, `comma_start'-1)
{txt}304{com}.         local paren_start = strpos("`remaining'", "(")
{txt}305{com}.         local paren_end = strpos("`remaining'", ")")
{txt}306{com}.         local controls = substr("`remaining'", 1, `paren_start'-1) + " " + substr("`remaining'", `paren_end'+1, .)
{txt}307{com}. 
.         local comma_start = strpos("`cmd'", ",")
{txt}308{com}.         local after_comma = substr("`cmd'", `comma_start'+1, .)
{txt}309{com}.         local has_nocon = regexm("`after_comma'", "(,noc|,noco|,nocon |,nocons|,noconst|,noconsta|,noconstan|,noconstant| noc| noco| nocon| nocons| noconst| noconsta| noconstan| noconstant)")
{txt}310{com}.         if `has_nocon' local nocons , nocons 
{txt}311{com}.         else local nocons
{txt}312{com}. 
.         local xtildecmd1 reg `endog' `instr' `controls' `nocons'
{txt}313{com}.         local xtildecmd2 reg __tmo_xhat `controls' `nocons'
{txt}314{com}.     {c )-}
{txt}315{com}. 
.     if "`spec'"=="ivregress" {c -(}
{txt}316{com}. 
.         * Extract the estimation method (2sls, gmm, liml, etc.)
.         local method = word("`cmd'", 2)
{txt}317{com}. 
.         * Create xtildecmd using ivreghdfe
.         local parens_start = strpos("`cmd'", "(")
{txt}318{com}.         local parens_end   = strpos("`cmd'", ")")
{txt}319{com}.         local paren_content = substr("`cmd'", `parens_start' + 1, `parens_end' - `parens_start' - 1)
{txt}320{com}. 
.         local instr_start = strpos("`paren_content'", "=")
{txt}321{com}.         local endog_part = substr("`paren_content'", 1, `instr_start'-1)
{txt}322{com}.         local endog      = word("`endog_part'", 1)
{txt}323{com}.         if wordcount("`endog_part'") > 1 {c -(}
{txt}324{com}.             di as error "Multiple endogenous regressors not supported"
{txt}325{com}.             exit
{txt}326{com}.         {c )-}
{txt}327{com}.         if "`endog'"!="`x'" {c -(}
{txt}328{com}.             di as error "Endogenous regressor `endog' is not `x'"
{txt}329{com}.             exit
{txt}330{com}.         {c )-}
{txt}331{com}.         local instr = substr("`paren_content'", `instr_start' + 1, .)
{txt}332{com}. 
.         local remaining = subinstr("`cmd'", "ivregress", "", 1)
{txt}333{com}.         local remaining = subinstr("`remaining'", "`method'","", 1)
{txt}334{com}.         local remaining = subinstr("`remaining'", "`y'", "", 1)
{txt}335{com}.         local comma_start = strpos("`remaining'", ",")
{txt}336{com}.         local remaining = substr("`remaining'", 1, `comma_start'-1)
{txt}337{com}.         local paren_start = strpos("`remaining'", "(")
{txt}338{com}.         local paren_end = strpos("`remaining'", ")")
{txt}339{com}.         local controls = substr("`remaining'", 1, `paren_start'-1) + " " + substr("`remaining'", `paren_end'+1, .)
{txt}340{com}. 
.         local comma_start = strpos("`cmd'", ",")
{txt}341{com}.         local after_comma = substr("`cmd'", `comma_start'+1, .)
{txt}342{com}.         local has_nocon = regexm("`after_comma'", "(,noc|,noco|,nocon |,nocons|,noconst|,noconsta|,noconstan|,noconstant| noc| noco| nocon| nocons| noconst| noconsta| noconstan| noconstant)")
{txt}343{com}.         if `has_nocon' local nocons , nocons 
{txt}344{com}.         else local nocons
{txt}345{com}. 
.         local xtildecmd1 reg `endog' `instr' `controls' `nocons'
{txt}346{com}.         local xtildecmd2 reg __tmo_xhat `controls' `nocons'
{txt}347{com}.     {c )-}
{txt}348{com}. 
.     *** END WRITE CMD FOR XTILDE ***
. 
.     
. 
.     ***************
.     *** RUN TMO ***
.     ***************
.     preserve
{txt}349{com}.         if "`load'"=="" {c -(} // if dyad data already exists, can load and skip this part (programmer option)
{txt}350{com}.             qui keep if `tmo_sample'
{txt}351{com}. 
.             * Estimate __tmo_xtilde
.             if  inlist("`spec'","regress","reghdfe","areg") {c -(}
{txt}352{com}.                 qui `xtildecmd'
{txt}353{com}.                 predict __tmo_xtilde, resid
{txt}354{com}.             {c )-}
{txt}355{com}.             if inlist("`spec'","ivreghdfe","ivreg2", "ivregress") {c -(}
{txt}356{com}.                 qui `xtildecmd1'
{txt}357{com}.                 qui predict __tmo_xhat
{txt}358{com}.                 qui `xtildecmd2'
{txt}359{com}.                 qui predict __tmo_xtilde, resid
{txt}360{com}.                 drop __tmo_xhat
{txt}361{com}.             {c )-}
{txt}362{com}. 
.             * Check __tmo_xtilde is correct
.             qui reg `y' __tmo_xtilde `weightexp'
{txt}363{com}.             if abs(beta-_b[__tmo_xtilde])>1e-5 {c -(}
{txt}364{com}.                 di as error "__tmo_xtilde is incorrect"
{txt}365{com}.                 exit
{txt}366{com}.             {c )-}
{txt}367{com}. 
.             * Loop through auxiliary outcomes and save residuals
.             cap drop __tmo_resid*
{txt}368{com}. 
.             if  inlist("`spec'","regress","ivreg2", "ivregress") {c -(}
{txt}369{com}.                 * Only keep cmd before comma (faster runtime)
.                 local comma_start = strpos("`cmd'",",")
{txt}370{com}.                 if `comma_start'>0 {c -(}
{txt}371{com}.                     local before_comma = substr("`cmd'",1,`comma_start'-1)
{txt}372{com}.                     local after_comma = substr("`cmd'", `comma_start'+1, .)
{txt}373{com}. 
.                     * Check whether there is nocons option and include if so
.                     local has_nocon = regexm("`after_comma'", "(,noc|,noco|,nocon |,nocons|,noconst|,noconsta|,noconstan|,noconstant| noc| noco| nocon| nocons| noconst| noconsta| noconstan| noconstant)")
{txt}374{com}.                     if `has_nocon' {c -(}
{txt}375{com}.                         local nocons , nocons 
{txt}376{com}.                     {c )-}
{txt}377{com}.                     else local nocons
{txt}378{com}.                 {c )-}
{txt}379{com}.                 else {c -(}
{txt}380{com}.                     local before_comma `cmd'
{txt}381{com}.                     local nocons
{txt}382{com}.                 {c )-}
{txt}383{com}.                 
.                 local cmd_toloop `before_comma' `nocons'
{txt}384{com}. 
.                 local ynum=1
{txt}385{com}.                 foreach aux_y in `y' `ylist' {c -(}
{txt}386{com}.                     local cmd_inloop = subinstr("`cmd_toloop'","`y'","`aux_y'",1)
{txt}387{com}.                     qui `cmd_inloop'
{txt}388{com}.                     qui predict __tmo_resid`ynum', resid
{txt}389{com}.                     local ++ynum
{txt}390{com}.                 {c )-}
{txt}391{com}.             {c )-}
{txt}392{com}.             
.             if "`spec'"=="reghdfe" {c -(}
{txt}393{com}.                 * Remove any clustering (faster runtime)
.                 //Note DC: build in catch for spaces between option name and parentheses
.                 local cmd_toloop `cmd'
{txt}394{com}.                 while regexm("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)") {c -(}
{txt}395{com}.                     local cmd_toloop = regexr("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)", "")
{txt}396{com}.                 {c )-}
{txt}397{com}. 
.                 local ynum=1
{txt}398{com}.                 foreach aux_y in `y' `ylist' {c -(}
{txt}399{com}.                     local cmd_inloop = subinstr("`cmd_toloop'","`y'","`aux_y'",1)
{txt}400{com}.                     qui `cmd_inloop' resid
{txt}401{com}.                     qui predict __tmo_resid`ynum', resid
{txt}402{com}.                     local ++ynum
{txt}403{com}.                 {c )-}
{txt}404{com}.             {c )-}
{txt}405{com}.             if "`spec'"=="areg" {c -(}
{txt}406{com}.                 * Remove any clustering (faster runtime)
.                 local cmd_toloop `cmd'
{txt}407{com}.                 while regexm("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)") {c -(}
{txt}408{com}.                     local cmd_toloop = regexr("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)", "")
{txt}409{com}.                 {c )-}
{txt}410{com}. 
.                 local ynum=1
{txt}411{com}.                 foreach aux_y in `y' `ylist' {c -(}
{txt}412{com}.                     local cmd_inloop = subinstr("`cmd_toloop'","`y'","`aux_y'",1)
{txt}413{com}.                     qui `cmd_inloop'
{txt}414{com}.                     qui predict __tmo_resid`ynum', resid
{txt}415{com}.                     local ++ynum
{txt}416{com}.                 {c )-}
{txt}417{com}.             {c )-}
{txt}418{com}.             if "`spec'"=="ivreghdfe" {c -(}
{txt}419{com}.                 * Remove any clustering (faster runtime)
.                 local cmd_toloop `cmd'
{txt}420{com}.                 while regexm("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)") {c -(}
{txt}421{com}.                     local cmd_toloop = regexr("`cmd_toloop'", "(cl|clu|clus|clust|cluste|cluster|vce)\([^)]*\)", "")
{txt}422{com}.                 {c )-}
{txt}423{com}. 
.                 * Specify FEs to save
.                 local absorb_start = regexm("`cmd'", "(a|ab|abs|abso|absor|absorb)\(([^)]+)\)")
{txt}424{com}.                 local absorb_vars "`=regexs(2)'"
{txt}425{com}.                 local absorb_vars_savefe
{txt}426{com}.                 local absorb_vars_fesum
{txt}427{com}.                 local fe=1
{txt}428{com}.                 foreach fe_var in `absorb_vars' {c -(}
{txt}429{com}.                     local absorb_vars_savefe `absorb_vars_savefe' __tmo_fe`fe'=`fe_var'
{txt}430{com}.                     local absorb_vars_fesum `absorb_vars_fesum' + __tmo_fe`fe'
{txt}431{com}.                     local ++fe
{txt}432{com}.                 {c )-}
{txt}433{com}.                 local cmd_toloop = regexr("`cmd_toloop'", "(a|ab|abs|abso|absor|absorb)\([^)]*\)", "")
{txt}434{com}.                 local cmd_toloop `cmd_toloop' absorb(`absorb_vars_savefe')
{txt}435{com}. 
.                 local ynum=1
{txt}436{com}.                 foreach aux_y in `y' `ylist' {c -(}
{txt}437{com}.                     local cmd_inloop = subinstr("`cmd_toloop'","`y'","`aux_y'",1)
{txt}438{com}.                     cap drop __tmo_fe*
{txt}439{com}.                     qui `cmd_inloop'
{txt}440{com}.                     cap drop __tmo_xb 
{txt}441{com}.                     qui predict __tmo_xb
{txt}442{com}.                     qui gen __tmo_resid`ynum' = `aux_y' - (__tmo_xb`absorb_vars_fesum')
{txt}443{com}.                     local ++ynum
{txt}444{com}.                 {c )-}
{txt}445{com}.             {c )-}
{txt}446{com}.             scalar D = `ynum'-1
{txt}447{com}. 
.             * Calculate correlation in residuals and contribution to variance
.             keep `idvar' `timevar' `weightvar' __tmo_xtilde __tmo_resid*
{txt}448{com}.             qui hashsort `idvar' `timevar'
{txt}449{com}. 
.             * Store data in Mata
.             mata: id = st_data(.,"`idvar'")
{txt}450{com}.             mata: xtilde = st_data(.,"__tmo_xtilde")
{txt}451{com}.             if "`weightvar'"!="" {c -(}
{txt}452{com}.                 mata: wgt = st_data(.,"`weightvar'")
{txt}453{com}.             {c )-}
{txt}454{com}.             else {c -(}
{txt}455{com}.                 mata: wgt = J(rows(xtilde),1,1)
{txt}456{com}.             {c )-}
{txt}457{com}.             mata: xtilde_wgt = xtilde:*wgt
{txt}458{com}.             mata: Res1 = st_data(.,"__tmo_resid1")
{txt}459{com}. 
.             mata: CovEpsVec = J(0,0,.)
{txt}460{com}.             mata: id_widerowvec = J(0,0,.)
{txt}461{com}.             mata: id_widecolvec = J(0,0,.)
{txt}462{com}.             mata: res1_widerowvec = J(0,0,.)
{txt}463{com}.             mata: res1_widecolvec = J(0,0,.)
{txt}464{com}.             mata: xtilde_widerowvec = J(0,0,.)
{txt}465{com}.             mata: xtilde_widecolvec = J(0,0,.)
{txt}466{com}. 
.             if "`timevar'"=="" {c -(} // Cross-sectional case
{txt}467{com}.                 * Compute correlation in outcomes
.                 //DC: Minor bottleneck here, but not too bad
.                 mata: Res = st_data(.,"__tmo_resid*")
{txt}468{com}.                 clear
{txt}469{com}.                 mata: corr_resid(id, Res, Res1, `misslimit', CovEpsVec, xtilde_wgt, id_widerowvec, id_widecolvec, res1_widerowvec, res1_widecolvec, xtilde_widerowvec, xtilde_widecolvec, N)
{txt}470{com}.                 mata: st_local("obsN",strofreal(rows(CovEpsVec),"%50.0f"))
{txt}471{com}.                 gen id1=.
{txt}472{com}.                 gen id2=.
{txt}473{com}.                 gen corr=.
{txt}474{com}. 
.                 qui set obs `obsN'
{txt}475{com}. 
.                 mata: st_store(.,.,(id_widerowvec,id_widecolvec,CovEpsVec))
{txt}476{com}. 
.                 qui gen corr_fisher = 0.5 * ln((1+corr)/(1-corr))
{txt}477{com}.                 cap drop offdiag
{txt}478{com}.                 qui gen byte offdiag = !missing(corr) & id1!=id2 & abs(corr)!=1
{txt}479{com}. 
.                 qui gstats sum corr_fisher if offdiag
{txt}480{com}.                 scalar sd = (r(p75)-r(p25))/(invnormal(0.75)-invnormal(0.25))
{txt}481{com}.                 scalar df = 1/(sd^2)
{txt}482{com}. 
.                 cap drop corr_fisher_abs 
{txt}483{com}.                 qui gen corr_fisher_abs = abs(corr_fisher)
{txt}484{com}.                 qui replace corr_fisher_abs = . if !offdiag // will be at end
{txt}485{com}.                 qui hashsort corr_fisher_abs
{txt}486{com}. 
.                 cap drop cdf_emp_abs_1min cdf_iqr_abs_1min q_iqr_abs
{txt}487{com}.                 qui count if offdiag
{txt}488{com}.                 qui gen cdf_emp_abs_1min = 1 - (_n/`r(N)') if offdiag
{txt}489{com}.                 qui gen cdf_iqr_abs_1min = 1 - 2*(normal(corr_fisher_abs/sd)-0.5) if offdiag
{txt}490{com}.                 qui gen q_iqr_abs = cdf_emp_abs_1min - 2*cdf_iqr_abs_1min if offdiag
{txt}491{com}. 
.                 qui sum q_iqr_abs if offdiag
{txt}492{com}.                 qui sum corr_fisher_abs if abs(q_iqr_abs-`r(max)')<=1e-10 & offdiag
{txt}493{com}.                 scalar fthres = `r(min)'
{txt}494{com}.                 scalar thres = tanh(fthres)
{txt}495{com}.                 local thres = thres
{txt}496{com}.      
.                * Compute contribution to SE for each pair of locations
.                 mata: ResXtildeVec = J(0,0,.)
{txt}497{com}. 
.                 //DC: THIS IS THE BOTTLENECK
.                 mata: sandwich_crosssec(id_widerowvec, id_widecolvec, res1_widerowvec, res1_widecolvec, xtilde_widerowvec, xtilde_widecolvec, CovEpsVec, ResXtildeVec, `thres')
{txt}498{com}.             {c )-}
{txt}499{com}.             else {c -(} // Panel case
{txt}500{com}.                 * Store data in Mata
.                 mata: t = st_data(.,"`timevar'")
{txt}501{com}. 
.                 ** Reshape Res
.                 * To make sure each location is shown for all time periods
.                 qui  tsset `idvar' `timevar'
{txt}502{com}.                 tsfill, full
{txt}503{com}. 
.                 * Drop time periods that are all missing for resids of main outcome 
.                 qui gegen __tmo_resid1_missing = sum(!missing(__tmo_resid1)), by(`timevar')
{txt}504{com}.                 qui drop if __tmo_resid1_missing==0
{txt}505{com}.                 drop __tmo_resid1_missing
{txt}506{com}.                 
.                 * Input NT x D matrix of residuals to Mata
.                 mata: Res = st_data(.,"__tmo_resid*")
{txt}507{com}.                 mata: Dn = cols(Res)
{txt}508{com}.                 mata: idfull = st_data(.,"`idvar'")
{txt}509{com}. 
.                 clear 
{txt}510{com}.                 * Reshape matrix of residuals to N x TD
.                 mata: Res = rowshape(Res,N)
{txt}511{com}.                 mata: Res1= rowshape(Res1,N)
{txt}512{com}.                 mata: id_wide = rowshape(idfull,N)
{txt}513{com}.                 mata: id_wide = id_wide[,1]
{txt}514{com}.                 mata: assert(rows(uniqrows(id_wide))==N)
{txt}515{com}.                 mata: assert(cols(Res)==Dn*T)
{txt}516{com}. 
.                 * Compute correlation in outcomes
.                 mata: corr_resid(id_wide, Res, Res1, `misslimit', CovEpsVec, xtilde_wgt, id_widerowvec, id_widecolvec, res1_widerowvec, res1_widecolvec, xtilde_widerowvec, xtilde_widecolvec, N)
{txt}517{com}.                 mata: st_local("obsN",strofreal(rows(*CovEpsVec),"%50.0f"))
{txt}518{com}.                     
.                 gen id1=.
{txt}519{com}.                 gen id2=.
{txt}520{com}.                 gen corr=.
{txt}521{com}. 
.                 qui set obs `obsN'
{txt}522{com}. 
.                 mata: st_store(.,.,(id_widerowvec,id_widecolvec,CovEpsVec))
{txt}523{com}.                 qui gen corr_fisher = 0.5 * ln((1+corr)/(1-corr))
{txt}524{com}.                 cap drop offdiag
{txt}525{com}.                 qui gen byte offdiag = !missing(corr) & id1!=id2 & abs(corr)!=1
{txt}526{com}. 
.                 qui gstats sum corr_fisher if offdiag
{txt}527{com}.                 scalar sd = (r(p75)-r(p25))/(invnormal(0.75)-invnormal(0.25))
{txt}528{com}.                 scalar df = 1/(sd^2)
{txt}529{com}. 
.                 cap drop corr_fisher_abs 
{txt}530{com}.                 qui gen corr_fisher_abs = abs(corr_fisher)
{txt}531{com}.                 qui replace corr_fisher_abs = . if !offdiag // will be at end
{txt}532{com}.                 qui hashsort corr_fisher_abs
{txt}533{com}. 
.                 cap drop cdf_emp_abs_1min cdf_iqr_abs_1min q_iqr_abs
{txt}534{com}.                 qui count if offdiag
{txt}535{com}.                 qui gen cdf_emp_abs_1min = 1 - (_n/`r(N)') if offdiag
{txt}536{com}.                 qui gen cdf_iqr_abs_1min = 1 - 2*(normal(corr_fisher_abs/sd)-0.5) if offdiag
{txt}537{com}.                 qui gen q_iqr_abs = cdf_emp_abs_1min - 2*cdf_iqr_abs_1min if offdiag
{txt}538{com}. 
.                 qui sum q_iqr_abs if offdiag
{txt}539{com}.                 qui sum corr_fisher_abs if abs(q_iqr_abs-`r(max)')<=1e-10 & offdiag
{txt}540{com}.                 scalar fthres = `r(min)'
{txt}541{com}.                 scalar thres = tanh(fthres)
{txt}542{com}.                 local thres = thres
{txt}543{com}.                 keep id1 id2 corr corr_fisher corr_fisher_abs q_iqr_abs offdiag
{txt}544{com}. 
.                 * Compute contribution to SE for each pair of locations
.                 sandwich_panel, rows(20000000) nloc(`N') ntime(`T') th(`thres') noi
{txt}545{com}.             {c )-}
{txt}546{com}.             * Normalize contribution to variance
.             mata: resxtildenorm(ResXtildeVec, xtilde_wgt)
{txt}547{com}. 
.             * Calculate part of contribution to scpc SE if specified
.             if "`scpc_cmd'"!="" {c -(}
{txt}548{com}.                 mata: y_scpc = (sqrt(N)/(xtilde'*xtilde)):*Res1:*xtilde 
{txt}549{com}.                 mata: st_local("scpc_obsN",strofreal(rows(id),"%50.0f"))
{txt}550{com}.                 
.                 clear
{txt}551{com}.                 gen id1=.
{txt}552{com}.                 gen y_scpc1=.
{txt}553{com}.                 
.                 qui set obs `scpc_obsN'
{txt}554{com}.                 
.                 mata: st_store(.,.,(id,y_scpc))
{txt}555{com}.                 
.                 cap gisid id1
{txt}556{com}.                 if _rc gcollapse (sum) y_scpc1, by(id1)
{txt}557{com}. 
.                 qui compress
{txt}558{com}.                 tempfile scpc1
{txt}559{com}.                 qui save `scpc1'
{txt}560{com}.                 
.                 rename id1 id2
{txt}561{com}.                 rename y_scpc1 y_scpc2
{txt}562{com}.                 
.                 tempfile scpc2
{txt}563{com}.                 qui save `scpc2'
{txt}564{com}.             {c )-}
{txt}565{com}. 
.             * Bring Mata data into Stata
.             if "`cluster'"!="" & "`cluster'"!="`idvar'" {c -(}
{txt}566{com}.                 local cl1p cl1path(`cl1')
{txt}567{com}.                 local cl2p cl2path(`cl2') 
{txt}568{com}.             {c )-}
{txt}569{com}.             else {c -(}
{txt}570{com}.                 local cl1p
{txt}571{com}.                 local cl2p
{txt}572{com}.             {c )-}
{txt}573{com}.             if "`filesuffix'"!="" {c -(}
{txt}574{com}.                 local savepath filesuffix(`filesuffix') 
{txt}575{com}.             {c )-}
{txt}576{com}.             else {c -(}
{txt}577{com}.                 local savepath
{txt}578{com}.             {c )-}
{txt}579{com}.             if "`longitude'"!="" & "`latitude'"!="" {c -(}
{txt}580{com}.                 local distp distpath(`dist')
{txt}581{com}.             {c )-}
{txt}582{com}.             else {c -(}
{txt}583{com}.                 local distp
{txt}584{com}.             {c )-}
{txt}585{com}.             if "`scpc_cmd'"!="" {c -(}
{txt}586{com}.                 local scpcw scpcwfin(`Wfin')
{txt}587{com}.                 local scpcy1 scpcy1path(`scpc1')
{txt}588{com}.                 local scpcy2 scpcy2path(`scpc2')
{txt}589{com}.             {c )-}
{txt}590{com}.             else {c -(}
{txt}591{com}.                 local scpcw
{txt}592{com}.                 local scpcy1
{txt}593{com}.                 local scpcy2
{txt}594{com}.             {c )-}
{txt}595{com}.             //quedan observaciones volando
.             load_data, nloc(`N') `cl1p' `cl2p' `distp' `savedyad' `savepath' `scpcw' `scpcy1' `scpcy2'
{txt}596{com}.         {c )-}
{txt}597{com}.         else {c -(}
{txt}598{com}.             if "`filesuffix'"!="" {c -(}
{txt}599{com}.                 local savepath filesuffix(`filesuffix') 
{txt}600{com}.             {c )-}
{txt}601{com}.             else {c -(}
{txt}602{com}.                 local savepath
{txt}603{com}.             {c )-}
{txt}604{com}. 
.             use "`load'_est.dta", clear
{txt}605{com}.             scalar D = N_outcomes[1]
{txt}606{com}. 
.             use "`load'_dyad.dta", clear
{txt}607{com}.         {c )-}
{txt}608{com}. 
.         * Compute TMO SE
.         est_tmo_se, dist_cutoff(`distthreshold') custom_thres(`threshold') `thresholdoff'
{txt}609{com}. 
.         * Plot TMO SE over threshold 
.         if "`plotse'"!="" {c -(}
{txt}610{com}.             tmo_over_thres, `savepath' `saveplotseest' noi dist_cutoff(`distthreshold')
{txt}611{com}.         {c )-}
{txt}612{com}. 
.         //CRETA FUNCTION FOR THIS
.         cap drop pdf_iqr
{txt}613{com}.         qui gen pdf_iqr = normalden(corr_fisher,sd) if offdiag
{txt}614{com}.         
.         if "`plotq'"!="" {c -(}        
{txt}615{com}.             qui sum corr_fisher_abs if q_iqr_abs>=-0.002 & offdiag
{txt}616{com}.             local xstart=floor(`r(min)'*10)/10
{txt}617{com}.             local fthres=fthres
{txt}618{com}. 
.             twoway ///
>                     (line q_iqr_abs corr_fisher_abs if q_iqr_abs>=-0.002 & corr_fisher_abs<=1, lcolor(blue) lwidth(medthick) sort(corr_fisher_abs)), ///
>                     graphregion(color(white)) ///
>                     yline(0, lcolor(gray)) ///
>                     xtitle("Threshold {c -(}it:{c -(}&delta{c )-}{c )-}") ytitle("") ///
>                     ylab(, angle(horizontal) format("%04.3f")) ///
>                     xlab(`xstart'(0.1)1, grid gmin gmax format("%02.1f")) ///
>                     xline(`fthres', lcolor(red)) ///
>                     xsize(16) ysize(9)
{txt}619{com}.             graph export "`filesuffix'_qt.pdf", as(pdf) replace
{txt}620{com}.         {c )-}
{txt}621{com}. 
.         if "`plothist'"!="" {c -(}
{txt}622{com}.             qui sum corr_fisher if offdiag
{txt}623{com}.             local binwidth = (`r(max)'-`r(min)')/`nbins'
{txt}624{com}.             qui gen bin_corr = floor((corr_fisher-`r(min)')/`binwidth') if offdiag
{txt}625{com}.             qui gen bin_cent = bin_corr*`binwidth' + `binwidth'/2 + `r(min)'
{txt}626{com}.             qui sum bin_corr if offdiag
{txt}627{com}.             assert abs(`r(max)'-`nbins')<=1
{txt}628{com}.             qui hashsort bin_corr corr_fisher
{txt}629{com}.             qui by bin_corr: gen binN=_N if offdiag
{txt}630{com}.             qui gen bin_dens = binN/(_N*`binwidth') if offdiag
{txt}631{com}.             qui gegen byte bin_tag = tag(bin_corr) if offdiag
{txt}632{com}.             
.             local thres_str = string(thres,"%03.2f")
{txt}633{com}.             local fthres_str = string(fthres,"%03.2f")
{txt}634{com}.             local df_str = string(df,"%05.2f")
{txt}635{com}.             local fthres = fthres
{txt}636{com}.             
.             twoway      (bar bin_dens bin_cent if bin_tag==1 & corr_fisher>=-1 & corr_fisher<=1, base(0) barwidth(`binwidth') color(midgreen%30)) ///
>                         (line pdf_iqr corr_fisher if corr_fisher>=-1 & corr_fisher<=1, sort(corr_fisher) lcolor(blue%90)) ///
>                         , graphregion(color(white)) ///
>                         xtitle("Fisher transformed correlation") ///
>                         ytitle("Density") ///
>                         ylab(, format(%02.1f) angle(horizontal)) ///
>                         xlab(-1(0.2)1, format(%02.1f)) ///
>                         xline(0, lcolor(gray) lpattern(longdash)) ///
>                         xline(`fthres', lcolor(red)) ///
>                         xline(-`fthres', lcolor(red)) ///
>                         legend(order(2 "IQR df=`df_str', {c -(}it:{c -(}&delta{c )-}{c )-}{c -(}sup:*{c )-}=`thres_str' (`fthres_str' Fisher transformed)") ///
>                                 pos(6) nobox region(color(none))) ///
>                         xsize(16) ysize(9)
{txt}637{com}.             graph export "`filesuffix'_hist.png", as(png) replace
{txt}638{com}.         {c )-}        
{txt}639{com}.     restore
{txt}640{com}. 
. 
.         **********************
.         *** OUTPUT RESULTS ***
.         **********************
.               
.             mat tmo_results = J(1,6,.)
{txt}641{com}.             mat rownames tmo_results = "`x'"
{txt}642{com}.             mat colnames tmo_results = "Coef" "TMO SE" "t" "P>|t|" "95% Conf" "Interval"
{txt}643{com}.             mat tmo_results[1,1] = beta
{txt}644{com}.             mat tmo_results[1,2] = tmo_se
{txt}645{com}.             mat tmo_results[1,3] = beta/tmo_se
{txt}646{com}.             mat tmo_results[1,4] = 2*ttail(df_r, abs(beta/tmo_se))
{txt}647{com}.             scalar lb = beta - invttail(df_r,0.025)*tmo_se
{txt}648{com}.             scalar ub = beta + invttail(df_r,0.075)*tmo_se
{txt}649{com}.             mat tmo_results[1,5] = lb
{txt}650{com}.             mat tmo_results[1,6] = ub
{txt}651{com}.             //matlist tmo_results, border(all) cspec(o2& %20s | %9.3f o2 & %9.3f o2 & %6.2f o2 & %4.3f o2 & %9.3f o2 & %9.3f o2 &) rspec(&-&)
. 
.             mat tmo_details = J(5,1,.)
{txt}652{com}.             mat rowname tmo_details = "Optimal threshold" "% of off-diag in SE est." "% >= threshold (excl. clusters/Conley)" "# outcomes" "Degrees of freedom" 
{txt}653{com}.             mat tmo_details[1,1] = thres
{txt}654{com}.             mat tmo_details[2,1] = offdP*100
{txt}655{com}.             mat tmo_details[3,1] = offdPnocl*100
{txt}656{com}.             mat tmo_details[4,1] = D
{txt}657{com}.             mat tmo_details[5,1] = df
{txt}658{com}.             
.             matrix b = beta
{txt}659{com}.             matrix V = tmo_se^2
{txt}660{com}. 
.             matrix colnames b = `x'
{txt}661{com}.             matrix colnames V = `x'
{txt}662{com}.             matrix rownames V = `x'
{txt}663{com}.             
.             local df = df_r
{txt}664{com}.             ereturn post b V, dof(`df') obs(`nobs') esample(`touse') depname(`depvar')
{txt}665{com}. 
.             ereturn scalar r2 = `r2'
{txt}666{com}.             ereturn scalar r2_a = `r2a'
{txt}667{com}.             ereturn scalar rmse = `rmse'
{txt}668{com}.             _coef_table_header, nomodeltest title(Linear Regression with TMO)
{txt}669{com}.             dis ""
{txt}670{com}.             _coef_table
{txt}671{com}.             matlist tmo_details, cspec(& %-68s & %9.3f &) rspec(- & & & & & -) coleqonly noblank
{txt}672{com}. 
.             //ereturn display, level(`level')
.             
.             ereturn scalar beta = beta
{txt}673{com}.             ereturn scalar orig_se = se
{txt}674{com}.             ereturn scalar tmo_se = tmo_se
{txt}675{com}.             ereturn scalar lb = lb
{txt}676{com}.             ereturn scalar ub = ub
{txt}677{com}.             ereturn scalar threshold = thres
{txt}678{com}.             ereturn scalar pct_ge_thres = offdP*100
{txt}679{com}.             ereturn scalar pct_ge_thres_nocl = offdPnocl*100
{txt}680{com}.             ereturn scalar T = T
{txt}681{com}.             ereturn scalar N_loc = N
{txt}682{com}.             ereturn scalar N_clust = N_clust
{txt}683{com}.             ereturn scalar N_outcomes = D
{txt}684{com}.             ereturn scalar N = N_obs
{txt}685{com}.             ereturn scalar dof = df
{txt}686{com}.             ereturn scalar finite_sample_dof = dof_adj
{txt}687{com}.             ereturn scalar df_r = df_r
{txt}688{com}.             ereturn scalar scpc_cv = ${c -(}scpc_cv{c )-}
{txt}689{com}. 
.         if "`saveest'"!="" {c -(}
{txt}690{com}.             tmo_save, `savepath'
{txt}691{com}.         {c )-}
{txt}692{com}.     end
{txt}
{com}. 
. 
. ***********************
. *** HELPER COMMANDS ***
. ***********************
. 
. * Function for computing correlation of residuals
. cap mata: mata drop corr_resid()
{txt}
{com}. mata
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}:         void corr_resid(real matrix id,
>                     real matrix Res, 
>                     real matrix Res1, 
>                     real scalar misslimit, 
>                     real matrix CovEpsVec,
>                     real matrix xtilde, 
>                     real matrix id_widerowvec, 
>                     real matrix id_widecolvec, 
>                     real matrix res1_widerowvec, 
>                     real matrix res1_widecolvec, 
>                     real matrix xtilde_widerowvec,
>                     real matrix xtilde_widecolvec,
>                     real scalar N)
>         {c -(}
>                 real matrix Res_ms, Res_ms_lethres, Res_ms_ind, Res_ms_ind_tr, Res_no_ms, Denom, ResSum_DinBoth, ResMean_DinBoth, ResMeanProd_DinBoth, CovEps, Sum_ResSq_DinBoth, ResSD_DinBoth, DenomCorr, DenomVec, LowTriInd, rowpos, colpos, idx
>                 real scalar demean
> 
>         // Drop outcomes that are missing for more than `misslimit'
>         Res_ms = colsum(Res:==.)
>         Res_ms_lethres = (Res_ms:/rows(Res)):<=misslimit
>         Res = select(Res,Res_ms_lethres)
>         Res
>         // standardize residuals
>         Res = Res:-J(rows(Res),1,colsum(Res):/colsum(Res:!=.))
>         Res = Res:/J(rows(Res),1,(colsum(Res:^2):/colsum(Res:!=.)):^0.5) // Studentize residuals
> 
>         assert (sum(abs(colsum(Res)):<1e-5)==cols(Res))
>         assert (sum(abs((colsum(Res:^2):/colsum(Res:!=.)):^0.5 :- 1):<1e-5)==cols(Res))
> 
>         // covariance of residuals -> correlations
>         Res_ms_ind = Res:!=. // keep track of missing (0==missing)
>         Res_ms_ind_tr = Res_ms_ind'
>         Res_no_ms = editmissing(Res,0) // Res with missing replaced with 0
>         Denom = Res_ms_ind*Res_ms_ind_tr // number of both nonmissing        
> 
>         ResSum_DinBoth = Res_no_ms * Res_ms_ind_tr
>         ResMean_DinBoth = ResSum_DinBoth :/ Denom
>         ResMeanProd_DinBoth = ResMean_DinBoth :* ResMean_DinBoth'
>         
>         demean=1 // set to 1 to make residuals mean 0 within each location
>         if (demean==1) {c -(}
>             CovEps = ((Res_no_ms*Res_no_ms'):/Denom) - (ResMean_DinBoth:*(ResSum_DinBoth':/Denom)) - (ResMean_DinBoth':*(ResSum_DinBoth:/Denom)) + ResMeanProd_DinBoth
>         {c )-}
>         else {c -(}
>             CovEps = ((Res_no_ms*Res_no_ms'):/Denom)
>         {c )-}
>         
>         Sum_ResSq_DinBoth = (Res_no_ms:^2) * Res_ms_ind_tr
>         ResSD_DinBoth = ((Sum_ResSq_DinBoth:/Denom) + (-2:*ResMean_DinBoth:*(ResSum_DinBoth:/Denom)) + ResMean_DinBoth:^2) :^ 0.5
>         
>         DenomCorr = ResSD_DinBoth :* ResSD_DinBoth'
>         
>         if (demean==1) {c -(}
>             CovEps = CovEps:/DenomCorr
>         {c )-}
>         else {c -(}
>             CovEps = CovEps :/ ((diagonal(CovEps):^0.5) * (diagonal(CovEps):^0.5)')
>         {c )-}
> 
>         // vectorize off-diag covariance of residuals
>         CovEpsVec = vec(CovEps)
>         LowTriInd = J(rows(CovEps),cols(CovEps),1)
>         _lowertriangle(LowTriInd,1)
>         LowTriInd = vec(LowTriInd)
>         CovEpsVec = select(CovEpsVec,LowTriInd)
> 
>         assert (rows(CovEpsVec)==rows(Res)*(rows(Res)+1)/2)
>         
>         // vectorize Denom
>         DenomVec = vec(Denom)
>         DenomVec = select(DenomVec,LowTriInd)
> 
>         // store id vectors
>         idx     = selectindex(LowTriInd)
>         rowpos  = mod(idx :- 1, N) :+ 1
>         colpos  = floor((idx :- 1) :/ N) :+ 1
>         id_widerowvec    = id[rowpos, .]
>         id_widecolvec    = id[colpos, .]
>         res1_widerowvec  = Res1[rowpos, .]
>         res1_widecolvec  = Res1[colpos, .]
>         xtilde_widerowvec  = (rowshape(xtilde,N))[rowpos, .]
>         xtilde_widecolvec  = (rowshape(xtilde,N))[colpos, .]
>         {c )-}

: end
{txt}{hline}

{com}. 
. * Function for computing contribution to SE for each pair of locations in cross-sectional case
. cap mata: mata drop sandwich_crosssec()
{txt}
{com}. mata
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}:     void sandwich_crosssec(real matrix id_widerowvec, 
>                            real matrix id_widecolvec,
>                            real matrix res1_widerowvec, 
>                            real matrix res1_widecolvec, 
>                            real matrix xtilde_widerowvec, 
>                            real matrix xtilde_widecolvec, 
>                            real matrix CovEpsVec,
>                            real matrix ResXtildeVec,
>                            real scalar thres)
>         {c -(}   
>         real matrix res_xtide1, indx_vec
> 
>         indx_vec = abs(CovEpsVec) :>= thres
> 
>         ResXtildeVec  = select((id_widerowvec, id_widecolvec, res1_widerowvec, res1_widecolvec, xtilde_widerowvec, xtilde_widecolvec), indx_vec)
> 
>         id_widerowvec = (ResXtildeVec)[.,1]
>         id_widecolvec = (ResXtildeVec)[.,2]
>         ResXtildeVec  = (ResXtildeVec[.,3]:* ResXtildeVec[.,4]):*(ResXtildeVec[.,5]:* ResXtildeVec[.,6])
>         ResXtildeVec  = (id_widerowvec, id_widecolvec, ResXtildeVec)
>     {c )-}
{txt}note: variable {bf:res_xtide1} unused.

{com}: end
{txt}{hline}

{com}. 
. * Functions for computing contribution to SE for each pair of locations in panel case
. cap program drop sandwich_panel
{txt}
{com}. program define sandwich_panel
{txt}  1{com}.     syntax , rows(int) nloc(int) ntime(int) th(real) [NOIsily]
{txt}  2{com}. 
.     preserve
{txt}  3{com}.     mata: keep    = abs(CovEpsVec) :>= `th'
{txt}  4{com}.     mata: res1all = select((res1_widerowvec, res1_widecolvec, id_widerowvec, id_widecolvec), keep)
{txt}  5{com}.     mata: xtall   = select((xtilde_widerowvec, xtilde_widecolvec), keep)
{txt}  6{com}.     mata: P       = rows(res1all)
{txt}  7{com}.     mata: st_local("P", strofreal(P, "%12.0f"))
{txt}  8{com}.     mata: Mres1  = res1all  
{txt}  9{com}.     mata: Mxt    = xtall    
{txt} 10{com}.     mata: Mout   = J(0,3,.)
{txt} 11{com}. 
.     local P     = `P'
{txt} 12{com}.     local chunk = `nloc' * `ntime' * `ntime'
{txt} 13{com}. 
.     forvalues start = 1(`chunk')`P' {c -(}
{txt} 14{com}.         local end = min(`start' + `chunk' - 1, `P')
{txt} 15{com}.         mata: sandwich_panel_loop(`start', `end', `ntime', ///
>                                    Mres1, Mxt, Mout)
{txt} 16{com}.     {c )-}
{txt} 17{com}.     mata: ResXtildeVec = Mout
{txt} 18{com}.     mata: st_numscalar("num_pairs", rows(ResXtildeVec))
{txt} 19{com}.     restore
{txt} 20{com}. end
{txt}
{com}. 
. cap mata: mata drop sandwich_panel_loop()
{txt}
{com}. mata
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}: void sandwich_panel_loop(real scalar start_i,
>                          real scalar end_i,
>                          real scalar T,
>                          real matrix Mres1,
>                          real matrix Mxt,
>                          real matrix Mout)
> {c -(}
>     real colvector Mout1
>     real matrix sub, usub, xsub, x_u, block, rowSumx_u
>     real scalar i, pairT
> 
>     pairT= 2*T
>     sub  = (Mres1)[start_i..end_i , .]
>     
>     usub = sub[., 1..pairT]
>     xsub = Mxt[start_i..end_i , .]
>     x_u  = usub:*xsub
>     rowSumx_u = rowsum(x_u[., T+1..pairT])
>     block = J(rows(x_u), T, .)
> 
>     for (i = 1; i <= T; i++) {c -(}
>         block[., i] = (x_u[., i] :* rowSumx_u)
>     {c )-}
>     Mout1 = rowsum(block)
>     Mout = Mout \ ( sub[., pairT+1], sub[., pairT+2], Mout1 )
> {c )-}

: end
{txt}{hline}

{com}. 
. * Function to normalize contribution to SE by 2*[X'X]^-1 and multiply off-diag by 2 (since only lower triangular)
. cap mata: mata drop resxtildenorm()
{txt}
{com}. mata
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}:     void resxtildenorm(real matrix ResXtildeVec, 
>                        real matrix xtilde_wgt)
>         {c -(}
>                 real matrix denom, offdiag
>         real colvector v
> 
>         v = ResXtildeVec[.,3]
>         denom = 1/(quadcross(xtilde_wgt,xtilde_wgt))^2
>                 offdiag = ResXtildeVec[.,1]:!=ResXtildeVec[.,2]
>         ResXtildeVec[,3] = (v :* denom) :* (1 :+ offdiag)
>     {c )-}

: end
{txt}{hline}

{com}. 
. * Function to load Mata data into Stata
. cap program drop load_data
{txt}
{com}. program define load_data,
{txt}  1{com}.     syntax, nloc(int) [cl1path(str)] [cl2path(str)] [distpath(str)] [savedyad] [filesuffix(str)] [scpcwfin(str)] [scpcy1path(str)] [scpcy2path(str)]
{txt}  2{com}.     
.     qui compress     
{txt}  3{com}.     tempfile corr
{txt}  4{com}.     qui save `corr'
{txt}  5{com}.     
.     clear
{txt}  6{com}.     mata: st_local("obsN",strofreal(rows(ResXtildeVec),"%50.0f"))
{txt}  7{com}. 
.     gen id1=.
{txt}  8{com}.     gen id2=.
{txt}  9{com}.     gen xxresxx=.
{txt} 10{com}. 
.     qui set obs `obsN'
{txt} 11{com}.     mata: st_store(.,.,(ResXtildeVec))
{txt} 12{com}. 
.     qui merge 1:1 id1 id2 using `corr', assert(2 3) nogen
{txt} 13{com}.     qui compress
{txt} 14{com}. 
.     if _N!=(`nloc'^2+`nloc')/2 {c -(}
{txt} 15{com}.         di as error "Number of location pairs is incorrect"
{txt} 16{com}.         exit
{txt} 17{com}.     {c )-}
{txt} 18{com}.     if "`cl1path'"!="" {c -(}
{txt} 19{com}.         qui merge m:1 id1 using `cl1path', assert(3) nogen
{txt} 20{com}.         qui merge m:1 id2 using `cl2path', assert(3) nogen
{txt} 21{com}.         gen byte same_cl = 0
{txt} 22{com}.         qui ds __tmo_cl1_*
{txt} 23{com}.         foreach var1 in `r(varlist)' {c -(}
{txt} 24{com}.             local var2 = subinstr("`var1'","_cl1_","_cl2_",1)
{txt} 25{com}.             qui replace same_cl = 1 if `var1'==`var2'
{txt} 26{com}.         {c )-}
{txt} 27{com}.     {c )-}
{txt} 28{com}. 
.     if "`distpath'"!="" {c -(}
{txt} 29{com}.         qui merge 1:1 id1 id2 using `distpath', assert(3) nogen
{txt} 30{com}.     {c )-}
{txt} 31{com}. 
.     if "`scpcwfin'"!="" {c -(}
{txt} 32{com}.         qui merge 1:1 id1 id2 using `scpcwfin', assert(1 3) nogen
{txt} 33{com}.         qui merge m:1 id1 using `scpcy1path', assert(1 3) nogen
{txt} 34{com}.         qui merge m:1 id2 using `scpcy2path', assert(1 3) nogen
{txt} 35{com}.         qui gen ryyr = (Wfin*y_scpc1*y_scpc2)*(1 + (id1!=id2))
{txt} 36{com}.     {c )-}
{txt} 37{com}. 
.     * Fisher-transform correlation
.     qui count if abs(corr)>1 & !missing(corr)
{txt} 38{com}.     if `r(N)'>0 {c -(}
{txt} 39{com}.         di as error "Correlations <-1 or >1 exist"
{txt} 40{com}.         exit
{txt} 41{com}.     {c )-}
{txt} 42{com}.     if "`savedyad'"!="" {c -(}
{txt} 43{com}.         save "`filesuffix'_dyad.dta", replace
{txt} 44{com}.     {c )-}
{txt} 45{com}. end
{txt}
{com}. 
. 
. * Function to estimate TMO SE
. cap program drop est_tmo_se
{txt}
{com}. program define est_tmo_se,
{txt}  1{com}.     syntax, [dist_cutoff(real 0)] [custom_thres(real -9)] [thresholdoff] [`scpc_uncond']
{txt}  2{com}. 
.     if `custom_thres'!=-9 {c -(}
{txt}  3{com}.         scalar thres = `custom_thres'
{txt}  4{com}.         scalar fthres = 0.5 * ln((1+thres)/(1-thres))
{txt}  5{com}.         scalar df = .
{txt}  6{com}.         scalar sd = .
{txt}  7{com}.     {c )-}
{txt}  8{com}. 
.     if "`thresholdoff'"!="" {c -(}
{txt}  9{com}.         scalar thres = .
{txt} 10{com}.         scalar fthres = .
{txt} 11{com}.         scalar df = .
{txt} 12{com}.         scalar sd = .
{txt} 13{com}.     {c )-}
{txt} 14{com}. 
.     cap confirm var same_cl
{txt} 15{com}.     if !_rc {c -(}
{txt} 16{com}.         local orig_cond (same_cl)
{txt} 17{com}.     {c )-}
{txt} 18{com}.     else {c -(}
{txt} 19{com}.         local orig_cond (id1==id2)
{txt} 20{com}.     {c )-}
{txt} 21{com}.     cap confirm var same_cl
{txt} 22{com}.     if !_rc {c -(}
{txt} 23{com}.         if `dist_cutoff'>0 {c -(}
{txt} 24{com}.             local keep_cond (same_cl | dist<=`dist_cutoff')
{txt} 25{com}.         {c )-}
{txt} 26{com}.         else {c -(}
{txt} 27{com}.             local keep_cond (same_cl)
{txt} 28{com}.         {c )-}
{txt} 29{com}.     {c )-}
{txt} 30{com}.     else {c -(}
{txt} 31{com}.         if `dist_cutoff'>0 {c -(}
{txt} 32{com}.             local keep_cond (id1==id2 | dist<=`dist_cutoff')
{txt} 33{com}.         {c )-}
{txt} 34{com}.         else {c -(}
{txt} 35{com}.             local keep_cond (id1==id2)
{txt} 36{com}.         {c )-}
{txt} 37{com}.     {c )-}
{txt} 38{com}. 
.     * For SCPC option
.     cap confirm var Wfin
{txt} 39{com}.     if !_rc {c -(}
{txt} 40{com}.         local scpc = 1
{txt} 41{com}.         * Check SCPC SE (might not equal if uncond option or if missing some locations due to missing coordinates)
.         qui count if missing(ryyr)
{txt} 42{com}.         if r(N)==0 & "`scpc_uncond'"=="" {c -(}
{txt} 43{com}.             qui sum ryyr
{txt} 44{com}.             if abs(scpc_se - sqrt(r(sum)))>1e-5 {c -(}
{txt} 45{com}.                 di as error "SCPC SE does not match"
{txt} 46{com}.                 exit
{txt} 47{com}.             {c )-}
{txt} 48{com}.         {c )-}
{txt} 49{com}.     {c )-}
{txt} 50{com}.     else {c -(}
{txt} 51{com}.         local scpc = 0
{txt} 52{com}.     {c )-}
{txt} 53{com}. 
.     * Back out finite sample degrees of freedom adjustment from original SE
.     qui sum xxresxx if `orig_cond'
{txt} 54{com}.     scalar dof_adj = se^2/r(sum)
{txt} 55{com}. 
.     * TMO SE
.     qui sum xxresxx
{txt} 56{com}.     local xxresxx_sum = r(sum)
{txt} 57{com}.     if `scpc'==1 {c -(}
{txt} 58{com}.         qui sum ryyr if (abs(corr)<thres | missing(corr)) & !`keep_cond'
{txt} 59{com}.         local ryyr_sum = r(sum)
{txt} 60{com}.     {c )-}
{txt} 61{com}.     else {c -(}
{txt} 62{com}.         local ryyr_sum = 0
{txt} 63{com}.     {c )-}
{txt} 64{com}.         scalar tmo_se = sqrt((`xxresxx_sum'+`ryyr_sum')*dof_adj)
{txt} 65{com}.     * Store no. off-diag
.     qui count if id1!=id2
{txt} 66{com}.     scalar offdN = r(N)
{txt} 67{com}.     qui count if !`orig_cond'
{txt} 68{com}.     scalar offdNnocl = r(N)
{txt} 69{com}. 
.     * Proportion off-diag included in SE calculation (including both clustering, Conley, and TMO)
.         qui count if (((abs(corr)>=thres) & !missing(corr)) | `keep_cond') & id1!=id2
{txt} 70{com}.         scalar offdP = r(N)/offdN
{txt} 71{com}. 
.     * Proportion off-diag over threshold outside clusters or Conley
.         qui count if (abs(corr)>=thres) & !missing(corr) & !`keep_cond'
{txt} 72{com}.         scalar offdPnocl = r(N)/offdNnocl
{txt} 73{com}. end
{txt}
{com}. 
. * Function to plot TMO SE over thresholds
. cap program drop tmo_over_thres
{txt}
{com}. program define tmo_over_thres,
{txt}  1{com}.     syntax, filesuffix(str) [saveplotseest] [NOIsily] [dist_cutoff(real 0)]
{txt}  2{com}. 
.     cap confirm var same_cl
{txt}  3{com}.     if !_rc {c -(}
{txt}  4{com}.         if `dist_cutoff'>0 {c -(}
{txt}  5{com}.             local keep_cond (same_cl | dist<=`dist_cutoff')
{txt}  6{com}.             local subtitle2 `" "(excluding within-cluster and -`dist_cutoff' correlations)" "'
{txt}  7{com}.         {c )-}
{txt}  8{com}.         else {c -(}
{txt}  9{com}.             local keep_cond (same_cl)
{txt} 10{com}.             local subtitle2 `" "(excluding within-cluster correlations)" "'
{txt} 11{com}.         {c )-}
{txt} 12{com}.     {c )-}
{txt} 13{com}.     else {c -(}
{txt} 14{com}.         if `dist_cutoff'>0 {c -(}
{txt} 15{com}.             local keep_cond (id1==id2 | dist<=`dist_cutoff')
{txt} 16{com}.             local subtitle2 `" "(excluding within-`dist_cutoff' correlations)" "'
{txt} 17{com}.         {c )-}
{txt} 18{com}.         else {c -(}
{txt} 19{com}.             local keep_cond (id1==id2)
{txt} 20{com}.             local subtitle2
{txt} 21{com}.         {c )-}
{txt} 22{com}.     {c )-}
{txt} 23{com}. 
.     cap confirm var Wfin
{txt} 24{com}.     if !_rc {c -(}
{txt} 25{com}.         local scpc = 1
{txt} 26{com}.     {c )-}
{txt} 27{com}.     else {c -(}
{txt} 28{com}.         local scpc = 0 
{txt} 29{com}.     {c )-}
{txt} 30{com}. 
.     * Initialize matrix to store results
.     mat tmo_over_thres = J(101,4,.)
{txt} 31{com}.         mat colnames tmo_over_thres = delta tmo_se offdP offdPnocl 
{txt} 32{com}. 
.     local row=1
{txt} 33{com}.     forv thr=0(0.01)1.01 {c -(}
{txt} 34{com}.         if "`noisily'"!="" {c -(}
{txt} 35{com}.             if mod(`row',20)==1 {c -(}
{txt} 36{com}.                 local thr_str = string(`thr',"%03.2f")
{txt} 37{com}.                 di "Calculating TMO SE over threshold at `thr_str'"
{txt} 38{com}.             {c )-}
{txt} 39{com}.         {c )-}
{txt} 40{com}. 
.         mat tmo_over_thres[`row',1]=`thr'
{txt} 41{com}.                 qui sum xxresxx if ((abs(corr)>=`thr') & !missing(corr)) | `keep_cond'
{txt} 42{com}.         local xxresxx_sum = r(sum)
{txt} 43{com}.         if `scpc'==1 {c -(}
{txt} 44{com}.             qui sum ryyr if (abs(corr)<thres | missing(corr)) & !`keep_cond'
{txt} 45{com}.             local ryyr_sum = r(sum)
{txt} 46{com}.         {c )-}
{txt} 47{com}.         else {c -(}
{txt} 48{com}.             local ryyr_sum = 0
{txt} 49{com}.         {c )-}    
{txt} 50{com}.                 mat tmo_over_thres[`row',2]=sqrt((`xxresxx_sum'+`ryyr_sum')*dof_adj)
{txt} 51{com}.                 qui count if (abs(corr)>=`thr') & !missing(corr) & !(id1==id2)
{txt} 52{com}.                 mat tmo_over_thres[`row',3]=r(N)/offdN
{txt} 53{com}.                 qui count if (abs(corr)>=`thr') & !missing(corr) & !(`keep_cond')
{txt} 54{com}.                 mat tmo_over_thres[`row',4]=r(N)/offdNnocl
{txt} 55{com}. 
.         local ++row
{txt} 56{com}.     {c )-}
{txt} 57{com}. 
.     * Plot TMO SE over threshold
.     clear
{txt} 58{com}.     qui svmat2 tmo_over_thres, names(col)
{txt} 59{com}.     qui compress
{txt} 60{com}. 
.     if "`saveplotseest'"!="" {c -(}
{txt} 61{com}.         save "`filesuffix'_tmo_se_over_thres.dta", replace
{txt} 62{com}.     {c )-}
{txt} 63{com}. 
.     qui gen tmo_orig_se_ratio = tmo_se/se
{txt} 64{com}.     qui replace tmo_orig_se_ratio = 0 if missing(tmo_orig_se_ratio)
{txt} 65{com}. 
.     local thres = thres
{txt} 66{com}.     twoway      (line tmo_orig_se_ratio delta, lcolor(black) lwidth(medthick)) ///
>                         , ///
>                         graphregion(color(white)) ///
>                         xlabel(0(0.1)1.0, format("%02.1f") grid gmin gmax) ///
>                         ylab(, angle(horizontal) gmin gmax) ///
>                         xtitle("Threshold {c -(}it:{c -(}&delta{c )-}{c )-}") ///
>                         subtitle("Ratio of TMO standard error to original", pos(11)) ytitle("") ///
>                         legend(off) ///
>                         yline(1, lcolor(gray%50) lwidth(thick)) ///
>                         xline(`thres', lcolor(red) lwidth(medthick)) ///
>                         xsize(16) ysize(9)
{txt} 67{com}.         graph export "`filesuffix'_se_ratio_over_thres.pdf", as(pdf) replace
{txt} 68{com}. 
.     twoway      (line offdPnocl delta if offdPnocl<=0.1, lcolor(black) lwidth(medthick)) ///
>                         , ///
>                         graphregion(color(white)) ///
>                         ylab(0(0.01)0.1, format("%03.2f") angle(horizontal) gmin gmax) ///
>                         xlabel(0(0.1)1.0, format("%02.1f") grid gmin gmax) ///
>                         xtitle("Threshold {c -(}it:{c -(}&delta{c )-}{c )-}") ///
>                         subtitle("Proportion of correlations {c -(}&ge{c )-} threshold" `subtitle2', pos(11)) ytitle("") ///
>                         legend(off) ///
>                         xline(`thres', lcolor(red) lwidth(medthick)) ///
>                         xsize(16) ysize(9)
{txt} 69{com}.         graph export "`filesuffix'_prop_above_thres.pdf", as(pdf) replace
{txt} 70{com}. end
{txt}
{com}. 
. * Function to save TMO results to dta file
. cap program drop tmo_save
{txt}
{com}. program define tmo_save,
{txt}  1{com}.     syntax, FILEsuffix(str)
{txt}  2{com}. 
.     preserve
{txt}  3{com}.         clear
{txt}  4{com}. 
.         qui set obs 1
{txt}  5{com}. 
.         qui gen beta = beta
{txt}  6{com}.         qui gen orig_se = se
{txt}  7{com}.         qui gen tmo_se = tmo_se
{txt}  8{com}.         qui gen lb = lb
{txt}  9{com}.         qui gen ub = ub
{txt} 10{com}.         qui gen threshold = thres
{txt} 11{com}.         qui gen pct_ge_thres = offdP*100
{txt} 12{com}.         qui gen pct_ge_thres_nocl = offdPnocl*100
{txt} 13{com}.         qui gen T = T
{txt} 14{com}.         qui gen N_loc = N
{txt} 15{com}.         qui gen N = N_obs
{txt} 16{com}.         qui gen N_clust = N_clust
{txt} 17{com}.         qui gen N_outcomes = D
{txt} 18{com}.         qui gen dof = df
{txt} 19{com}.         qui gen finite_sample_dof = dof_adj
{txt} 20{com}.         qui gen df_r = df_r
{txt} 21{com}.         qui gen scpc_cv = ${c -(}scpc_cv{c )-}
{txt} 22{com}. 
.         qui compress
{txt} 23{com}.         save "`filesuffix'_est.dta", replace
{txt} 24{com}.     restore
{txt} 25{com}. 
. end
{txt}
{com}. 
{txt}end of do-file

{com}. *use "https://raw.githubusercontent.com/wjnkim/tmo/master/example/county_differences.dta", clear
. *save county_differences, replace
. use county_differences, clear
{txt}
{com}. 
. qui ds fips stfips PIN_persincpc_d EDU_college_d, not
{txt}
{com}. local ylist `r(varlist)'
{txt}
{com}. 
. sjlog using "$SJ/cmdexamples.tex", replace
{smcl}
{com}{sf}{ul off}